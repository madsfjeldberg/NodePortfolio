<section id="introduction">
  <h2 class="text-2xl font-semibold text-dark-text mb-4">JavaScript Basics</h2>
  <p class="text-dark-text-secondary mb-4">
    JavaScript is a weakly typed programming language, and is one of the most popular languages in the world.
    For a long time, it was used only in the browser, but with Node.js, it's now possible to use it on the server side as well.
    It's very versatile, and can be used for scripts, apps, games, and more.
  </p>
  </section>

  <section id="types">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Types</h3>
    <p class="text-dark-text-secondary mb-4">
      there are 7 primitive types in JavaScript:
      <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
        <li><code class="inline">number</code> - any number, javascript has no distinction between integers and floats</li>
        <li><code class="inline">string</code> - any sequence of characters, enclosed in quotes</li>
        <li><code class="inline">boolean</code> - true or false</li>
        <li><code class="inline">null</code> - an empty value</li>
        <li><code class="inline">undefined</code> - a value that is not defined</li>
        <li><code class="inline">symbol</code> - a unique and immutable data type that's often used as an identifier for object properties</li>
        <li><code class="inline">bigint</code> - a numeric data type that can represent integers larger than 2^53</li>
        <li><code class="inline">object</code> - a collection of properties</li>
      </ul>

      <p class="text-dark-text-secondary mb-4">
        Being weakly typed, JavaScript will automatically try to convert types when necessary:
      </p>
      <pre class="language-javascript">
let number = 10;
let string = "10";
// here the number is converted to a string and concatenated
number + string; // "1010"
      </pre>
      <p class="text-dark-text-secondary mb-4">
        This is called Type Coercion. Because of this, there are two types of equality operators:
        <br>
        <code class="inline">==</code> - checks for value equality, without considering type
        <br>
        <code class="inline">===</code> - checks for value equality and type
      </p>
      <pre class="language-javascript">
console.log(10 == "10"); // true
console.log(10 === "10"); // false
      </pre>
      <p class="text-dark-text-secondary mb-4">
        As a general rule, you should use the strict equality operator <code class="inline">===</code> to compare values,
        <br>
        as it's more strict and less prone to bugs.

      </p>
      
      
    </section>

  <section id="variables">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Variables</h3>
    <p class="text-dark-text-secondary mb-4">
      in JavaScript, there are three ways to declare variables:
    </p>
    <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
      <li><code class="inline">let</code></li>
      <li><code class="inline">const</code></li>
      <li><code class="inline">var</code></li>
    </ul>
    <p class="text-dark-text-secondary mb-4">
      If you don't expect a variable to change, use <code class="inline">const</code>.
      </p>
      <pre class="language-javascript">
const x = 10;
x = 20; // This will throw an error

// however, this is allowed:
const myList = [1, 2, 3];
myList.push(4); // This is allowed
myList.pop(); // This is also fine

myList = [1, 2, 3, 4, 5]; // This will throw an error
      </pre>
      <p class="text-dark-text-secondary mb-4">
      When making objects with <code class="inline">const</code>, you can still change the properties of the object.
      <br>
      But you can't reassign the variable to a different object.
      <br>
      <br>
      If you expect a variable to change, use <code class="inline">let</code>.
      <br>
      Note that you can even reassign the variable to a different type:
      <pre class="language-javascript">
let x = 10;
x = 20; // This is allowed
x = "fish"; // This is also allowed
x = true; // completely fine
      </pre>
      <p class="text-dark-text-secondary mb-4">
        If you want a lot of bugs, use <code class="inline">var</code>.
        <br>
        There really isn't a reason to use it, and it's not used in modern JavaScript.
        The biggest issue with <code class="inline">var</code> is that it's function scoped,
        meaning that it's accessible anywhere in the function it's declared in.
        <br>
        Whereas <code class="inline">let</code> and <code class="inline">const</code> are block scoped,
        meaning that they're only accessible within the block they're declared in, giving you more control over their scope.
      </p>
  </section>

  <section id="functions">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Functions</h3>
    <p class="text-dark-text-secondary mb-4">
      There are two types of functions in JavaScript:
    </p>
    <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
      <li><code class="inline">Arrow functions</code></li>
      <li><code class="inline">Regular functions</code></li>
    </ul>
    <p class="text-dark-text-secondary mb-4">
      Arrow functions are a newer way to write functions, and are more concise.
      <br>
      They also have a different way of handling the <code class="inline">this</code> keyword.
    </p>
    <pre class="language-javascript">
function myFunction() {
console.log("Hello, world!");
}

const myArrowFunction = () => {
console.log("Hello, world!");
}

myFunction(); // "Hello, world!"
myArrowFunction(); // "Hello, world!"
    </pre>
    <p class="text-dark-text-secondary mb-4">
      Regular functions are the older way to write functions, While arrow functions were introduced in ES6.
      <br>
      Arrow functions were designed to be more concise and easier to read.
      <br>
      They can also be shortened like this:
      <pre class="language-javascript">
const myArrowFunction = () => console.log("Hello, world!");
myArrowFunction(); // "Hello, world!"

/ And when passing parameters, you can even leave out the parentheses:
const myArrowFunction = name => console.log(`Hello, ${name}!`);
myArrowFunction("John"); // "Hello, John!"
      </pre>
      
      
      
    </p>
    
  </section>