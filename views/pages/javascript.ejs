<section id="introduction">
  <h2 class="text-2xl font-semibold text-dark-text mb-4">JavaScript Basics</h2>
  <p class="text-dark-text-secondary mb-4">
    JavaScript is a weakly typed programming language, and is one of the most popular languages in the world.
    For a long time, it was used only in the browser, but with Node.js, it's now possible to use it on the server side as well.
    It's very versatile, and can be used for scripts, apps, games, and more.
  </p>
  </section>

  <section id="types">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Types</h3>
    <p class="text-dark-text-secondary mb-4">
      there are 7 primitive types in JavaScript:
      <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
        <li><code class="inline">number</code> - any number, javascript has no distinction between integers and floats</li>
        <li><code class="inline">string</code> - any sequence of characters, enclosed in quotes</li>
        <li><code class="inline">boolean</code> - true or false</li>
        <li><code class="inline">null</code> - an empty value</li>
        <li><code class="inline">undefined</code> - a value that is not defined</li>
        <li><code class="inline">symbol</code> - a unique and immutable data type that's often used as an identifier for object properties</li>
        <li><code class="inline">bigint</code> - a numeric data type that can represent integers larger than 2^53</li>
        <li><code class="inline">object</code> - a collection of properties</li>
      </ul>

      <p class="text-dark-text-secondary mb-4">
        Being weakly typed, JavaScript will automatically try to convert types when necessary:
      </p>
      <pre class="language-javascript">
let number = 10;
let string = "10";
// here the number is converted to a string and concatenated
number + string; // "1010"
      </pre>
      <p class="text-dark-text-secondary mb-4">
        This is called Type Coercion. Because of this, there are two types of equality operators:
        <br>
        <code class="inline">==</code> - checks for value equality, without considering type
        <br>
        <code class="inline">===</code> - checks for value equality and type
      </p>
      <pre class="language-javascript">
console.log(10 == "10"); // true
console.log(10 === "10"); // false
      </pre>
      <p class="text-dark-text-secondary mb-4">
        As a general rule, you should use the strict equality operator <code class="inline">===</code> to compare values,
        <br>
        as it's more strict and less prone to bugs.

      </p>
      
      
    </section>

  <section id="variables">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Variables</h3>
    <p class="text-dark-text-secondary mb-4">
      in JavaScript, there are three ways to declare variables:
    </p>
    <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
      <li><code class="inline">let</code></li>
      <li><code class="inline">const</code></li>
      <li><code class="inline">var</code></li>
    </ul>
    <p class="text-dark-text-secondary mb-4">
      If you don't expect a variable to change, use <code class="inline">const</code>.
      </p>
      <pre class="language-javascript">
const x = 10;
x = 20; // This will throw an error

// however, this is allowed:
const myList = [1, 2, 3];
myList.push(4); // This is allowed
myList.pop(); // This is also fine

myList = [1, 2, 3, 4, 5]; // This will throw an error
      </pre>
      <p class="text-dark-text-secondary mb-4">
      When making objects with <code class="inline">const</code>, you can still change the properties of the object.
      <br>
      But you can't reassign the variable to a different object.
      <br>
      <br>
      If you expect a variable to change, use <code class="inline">let</code>.
      <br>
      Note that you can even reassign the variable to a different type:
      <pre class="language-javascript">
let x = 10;
x = 20; // This is allowed
x = "fish"; // This is also allowed
x = true; // completely fine
      </pre>
      <p class="text-dark-text-secondary mb-4">
        If you want a lot of bugs, use <code class="inline">var</code>.
        <br>
        There really isn't a reason to use it, and it's not used in modern JavaScript.
        The biggest issue with <code class="inline">var</code> is that it's function scoped,
        meaning that it's accessible anywhere in the function it's declared in.
        <br>
        Whereas <code class="inline">let</code> and <code class="inline">const</code> are block scoped,
        meaning that they're only accessible within the block they're declared in, giving you more control over their scope.
      </p>
  </section>

  <section id="objects">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Objects</h3>

    <p class="text-dark-text-secondary mb-4">
      Object in JavaScript are variables, that can contain multiple values and methods.
      They are typically declared with <code class="inline">const</code>, since we can still change the contents of the object,
      But not accidentally overwrite it.
      <br>
      Objects can defined three different ways:
    </p>
    <pre class="language-javascript">
// Object literal
{ firstName: "John", lastName: "Doe", age: 50 }

// standard method
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50
}

// using the "new" keyword
const person = new Object();

// create new values with dot notation
person.firstName = "John";
person.lastName = "Doe";
person.age = 50;
      </pre>

    <p class="text-dark-text-secondary mb-4">
    These values are called <i>properties</i>, and can be accessed in two ways:
    </p>
    <pre class="language-javascript">
person.firstName // "John"
person["age"] // 50    
    </pre>

    <p class="text-dark-text-secondary mb-4">
      Objects can also store functions, although when stored in a object, they are called <i>methods</i>.
    </p>

    <pre class="language-javascript">
const person = {
  firstName: "John",
  lastName : "Doe",
  id       : 5566,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};

person.fullName() // "John Doe"
    </pre>
    <p class="text-dark-text-secondary mb-4">
      Objects can also store other objects as properties.
      <br>
      If you're familiar with json, this will seem familiar:
    </p>
    <pre class="language-javascript">
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  address: {
    street: "123 Main St",
    city: "Boston",
    state: "MA",
    zip: "02108"
  },
  contacts: {
    email: "john@example.com",
    phone: {
      home: "555-1234",
      mobile: "555-5678"
    }
  }
};

// Access nested properties using dot notation
console.log(person.address.city); // "Boston"
console.log(person.contacts.phone.mobile); // "555-5678"
    </pre>

    <p class="text-dark-text-secondary mb-4">
      Sometimes you need to create several of the same object, but with different values. <br>
      This is where <i>constructors</i> become handy. <br>
      Lets say we need an easy way to create a lot of new <code class="inline">Employee</code> objects for our company:
    </p>
    <pre class="language-javascript">
// function that creates new Employee objects
const Employee = (firstName, lastName, age) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.age = age;
  // lets assume we're only hiring developers, then we can hardcode it like so:
  this.position = "Developer";
  // without having to pass it as an argument every time.
} 
    </pre> 
    <p class="text-dark-text-secondary mb-4">
      Then we can create easily create new Employees like this:
    </p>
    <pre class="language-javascript">
const employee1 = new Employee("John", "Doe", 35);
const employee2 = new Employee("Anders", "Latif", 30);

// we can still update the values:
employee2.position = "Senior Developer";
    </pre>

    <p class="mb-4">
      NOTE: constructors <i>has</i> to be normal functions, not arrow functions.
    </p>

  </section>

  <section id="functions">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Functions</h3>
    <p class="text-dark-text-secondary mb-4">
      There are two types of functions in JavaScript:
    </p>
    <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
      <li><code class="inline">Arrow functions</code></li>
      <li><code class="inline">Regular functions</code></li>
    </ul>
    <p class="text-dark-text-secondary mb-4">
      Arrow functions are a newer way to write functions, and are more concise.
      <br>
      They also have a different way of handling the <code class="inline">this</code> keyword.
    </p>
    <pre class="language-javascript">
function myFunction() {
console.log("Hello, world!");
}

const myArrowFunction = () => {
console.log("Hello, world!");
}

myFunction(); // "Hello, world!"
myArrowFunction(); // "Hello, world!"
    </pre>
    < class="text-dark-text-secondary mb-4">
      Regular functions are the older way to write functions, While arrow functions were introduced in ES6.
      <br>
      Arrow functions were designed to be more concise and easier to read.
      <br>
      They can also be shortened like this:
      <pre class="language-javascript">
const myArrowFunction = () => console.log("Hello, world!");
myArrowFunction(); // "Hello, world!"

/ And when passing parameters, you can even leave out the parentheses:
const myArrowFunction = name => console.log(`Hello, ${name}!`);
myArrowFunction("John"); // "Hello, John!"
      </pre>
    </section>

      <section id="callbacks">
        <hr class="my-6 border-t border-dark-border mt-8" />
        <h3 class="text-xl font-semibold text-dark-text mb-4">Callbacks</h3>
        <p class="text-dark-text-secondary mb-4">
          Callbacks are simply functions that are passed as arguments to other functions.
          When passing a function as a parameter, it's important to do so <i>without</i> parentheses:
          <pre class="language-javascript">
function myLogger(text) {
  console.log(text);
}

// for this example, we want to use myLogger as the callback
function myCalculator(num1, num2, callback) {
  let sum = num1 + num2;
  callback(sum);
}

// should be passed without ()
myCalculator(1, 1, myLogger) // 2

// if passed with (), myLogger will just be run immediately.
myCalculator(1, 1, myLogger()) // error
          </pre>
      <p class="text-dark-text-secondary mb-4">
        Callback functions don't seem all that useful in this example,
        but where they do get useful is in asynchronous functions, where functions has to wait
        for another to complete.
      </p>
      

      </section>
      
      <section id="promises">
        <hr class="my-6 border-t border-dark-border mt-8" />
        <h3 class="text-xl font-semibold text-dark-text mb-4">Promises</h3>
        <p class="text-dark-text-secondary mb-4">
          JavaScript is single-threaded, meaning that it can only execute one task at a time.
          This can be a problem, if you have a function that takes a long time to complete. <br>
          If you have a function that fetches data from a server, it will block the main thread,
          and won't be able to do anything else until it's finished. <br>
          To solve this issue, we can use <i>Promises</i>. <br><br>
          A <i>Promise</i> in JavaScript is an object that represents the eventual completion (or failure) of an asynchronous operation,
          and its resulting value. <br>
          More plainly, a Promise is an object that may produce a single value some time in the future: either a resolved value (e.g. some data from a server), or a reason that it's not resolved (e.g., a network error occurred).
          <br>
          A Promise can be in one of three states:
          <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
            <li><b>pending</b> - the initial state of the Promise</li>
            <li><b>fulfilled</b> - the operation was successful</li>
            <li><b>rejected</b> - the operation failed</li>
          </ul>
        </p>
        <p class="text-dark-text-secondary mb-4">
          example fetch function:
          </p>
          <pre class="language-javascript">
function fetchData() {
  return fetch("https://someAPI.com/api/data")
    .then(response => response.json())
    .then(data => data)
    .catch(error => error);
}

fetchData()
  .then(data => console.log(data))
  .catch(error => console.log(error));
          </pre>
        <p class="text-dark-text-secondary mb-4">
          In this example, we have a function called <code class="inline">fetchData()</code> that fetches data from a JSON placeholder API.
           The function returns a Promise that will eventually resolve with the data or reject with an error.<br><br>
          The <code class="inline">fetch()</code> function makes an HTTP request and returns a Promise. 
          When the Promise eventually resolves, we chain multiple <code class="inline">.then()</code> calls to handle the response - first converting it to JSON, then returning the data. <br>
          If any errors occur during this process, they are caught in the <code class="inline">.catch()</code> block.
          <br><br>
          When we call <code class="inline">fetchData()</code>, we handle the returned Promise by using <code class="inline">.then()</code> to log the successful data or <code class="inline">.catch()</code> to log any errors. <br>
          This asynchronous approach allows other code to continue executing while waiting for the network request to complete.
          <br><br>
          This function can also be written using <i>async/await</i> syntax:
        </p>
          <pre class="language-javascript">
async function fetchData() {
  try {
    const response = await fetch("https://someAPI.com/api/data");
    const data = await response.json();
    return data;
  } catch (error) {
    return error;
  }
}

fetchData()
  .then(data => console.log(data))
  .catch(error => console.log(error));
          </pre>
          <p class="text-dark-text-secondary mb-4">
          The <i>async</i> keyword is used to declare a function as asynchronous, meaning it implicitly returns a Promise.
          <br>
          The <i>await</i> keyword is used to pause execution until a Promise is resolved.
          <br>
          We can still use <code class="inline">.then()</code> and <code class="inline">.catch()</code> when calling the function.
          </p>





      </section>