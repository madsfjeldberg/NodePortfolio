<section id="introduction">
  <h2 class="text-2xl font-semibold text-dark-text mb-4">JavaScript Basics</h2>
  <p class="text-dark-text-secondary mb-4">
    JavaScript is a weakly typed programming language, and is one of the most popular languages in the world.
    For a long time, it was used only in the browser, but with Node.js, it's now possible to use it on the server side as well.
    It's very versatile, and can be used for scripts, apps, games, and more.
  </p>
  </section>

  <section id="types">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Types</h3>
    <p class="text-dark-text-secondary mb-4">
      there are 7 primitive types in JavaScript:
      <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
        <li><code class="inline">number</code> - any number, javascript has no distinction between integers and floats</li>
        <li><code class="inline">string</code> - any sequence of characters, enclosed in quotes</li>
        <li><code class="inline">boolean</code> - true or false</li>
        <li><code class="inline">null</code> - an empty value</li>
        <li><code class="inline">undefined</code> - a value that is not defined</li>
        <li><code class="inline">symbol</code> - a unique and immutable data type that's often used as an identifier for object properties</li>
        <li><code class="inline">bigint</code> - a numeric data type that can represent integers larger than 2^53</li>
        <li><code class="inline">object</code> - a collection of properties</li>
      </ul>

      <p class="text-dark-text-secondary mb-4">
        Being weakly typed, JavaScript will automatically try to convert types when necessary:
      </p>
      <pre class="language-javascript">
let number = 10;
let string = "10";
// here the number is converted to a string and concatenated
number + string; // "1010"
      </pre>
      <p class="text-dark-text-secondary mb-4">
        This is called Type Coercion. Because of this, there are two types of equality operators:
        <br>
        <code class="inline">==</code> - checks for value equality, without considering type
        <br>
        <code class="inline">===</code> - checks for value equality and type
      </p>
      <pre class="language-javascript">
console.log(10 == "10"); // true
console.log(10 === "10"); // false
      </pre>
      <p class="text-dark-text-secondary mb-4">
        As a general rule, you should use the strict equality operator <code class="inline">===</code> to compare values,
        <br>
        as it's more strict and less prone to bugs.

      </p>
      
      
    </section>

  <section id="variables">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Variables</h3>
    <p class="text-dark-text-secondary mb-4">
      in JavaScript, there are three ways to declare variables:
    </p>
    <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
      <li><code class="inline">let</code></li>
      <li><code class="inline">const</code></li>
      <li><code class="inline">var</code></li>
    </ul>
    <p class="text-dark-text-secondary mb-4">
      If you don't expect a variable to change, use <code class="inline">const</code>.
      </p>
      <pre class="language-javascript">
const x = 10;
x = 20; // This will throw an error

// however, this is allowed:
const myList = [1, 2, 3];
myList.push(4); // This is allowed
myList.pop(); // This is also fine

myList = [1, 2, 3, 4, 5]; // This will throw an error
      </pre>
      <p class="text-dark-text-secondary mb-4">
      When making objects with <code class="inline">const</code>, you can still change the properties of the object.
      <br>
      But you can't reassign the variable to a different object.
      <br>
      <br>
      If you expect a variable to change, use <code class="inline">let</code>.
      <br>
      Note that you can even reassign the variable to a different type:
      <pre class="language-javascript">
let x = 10;
x = 20; // This is allowed
x = "fish"; // This is also allowed
x = true; // completely fine
      </pre>
      <p class="text-dark-text-secondary mb-4">
        If you want a lot of bugs, use <code class="inline">var</code>.
        <br>
        There really isn't a reason to use it, and it's not used in modern JavaScript.
        The biggest issue with <code class="inline">var</code> is that it's function scoped,
        meaning that it's accessible anywhere in the function it's declared in.
        <br>
        Whereas <code class="inline">let</code> and <code class="inline">const</code> are block scoped,
        meaning that they're only accessible within the block they're declared in, giving you more control over their scope.
      </p>
  </section>

  <section id="objects">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Objects</h3>

    <p class="text-dark-text-secondary mb-4">
      Object in JavaScript are variables, that can contain multiple values and methods.
      They are typically declared with <code class="inline">const</code>, since we can still change the contents of the object,
      But not accidentally overwrite it.
      <br>
      Objects can defined three different ways:
    </p>
    <pre class="language-javascript">
// Object literal
{ firstName: "John", lastName: "Doe", age: 50 }

// standard method
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50
}

// using the "new" keyword
const person = new Object();

// create new values with dot notation
person.firstName = "John";
person.lastName = "Doe";
person.age = 50;
      </pre>

    <p class="text-dark-text-secondary mb-4">
    These values are called <i>properties</i>, and can be accessed in two ways:
    </p>
    <pre class="language-javascript">
person.firstName // "John"
person["age"] // 50    
    </pre>

    <p class="text-dark-text-secondary mb-4">
      Objects can also store functions, although when stored in a object, they are called <i>methods</i>.
    </p>

    <pre class="language-javascript">
const person = {
  firstName: "John",
  lastName : "Doe",
  id       : 5566,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};

person.fullName() // "John Doe"
    </pre>
    <p class="text-dark-text-secondary mb-4">
      Objects can also store other objects as properties.
      <br>
      If you're familiar with json, this will seem familiar:
    </p>
    <pre class="language-javascript">
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  address: {
    street: "123 Main St",
    city: "Boston",
    state: "MA",
    zip: "02108"
  },
  contacts: {
    email: "john@example.com",
    phone: {
      home: "555-1234",
      mobile: "555-5678"
    }
  }
};

// Access nested properties using dot notation
console.log(person.address.city); // "Boston"
console.log(person.contacts.phone.mobile); // "555-5678"
    </pre>

    <p class="text-dark-text-secondary mb-4">
      Sometimes you need to create several of the same object, but with different values. <br>
      This is where <i>constructors</i> become handy. <br>
      Lets say we need an easy way to create a lot of new <code class="inline">Employee</code> objects for our company:
    </p>
    <pre class="language-javascript">
// function that creates new Employee objects
const Employee = (firstName, lastName, age) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.age = age;
  // lets assume we're only hiring developers, then we can hardcode it like so:
  this.position = "Developer";
  // without having to pass it as an argument every time.
} 
    </pre> 
    <p class="text-dark-text-secondary mb-4">
      Then we can create easily create new Employees like this:
    </p>
    <pre class="language-javascript">
const employee1 = new Employee("John", "Doe", 35);
const employee2 = new Employee("Anders", "Latif", 30);

// we can still update the values:
employee2.position = "Senior Developer";
    </pre>

    <p class="mb-4">
      NOTE: constructors <i>has</i> to be normal functions, not arrow functions.
    </p>

  </section>

  <section id="functions">
    <hr class="my-6 border-t border-dark-border mt-8" />
    <h3 class="text-xl font-semibold text-dark-text mb-4">Functions</h3>
    <p class="text-dark-text-secondary mb-4">
      There are two types of functions in JavaScript:
    </p>
    <ul class="list-disc pl-6 mt-2 mb-4 text-dark-text-secondary">
      <li><code class="inline">Arrow functions</code></li>
      <li><code class="inline">Regular functions</code></li>
    </ul>
    <p class="text-dark-text-secondary mb-4">
      Arrow functions are a newer way to write functions, and are more concise.
      <br>
      They also have a different way of handling the <code class="inline">this</code> keyword.
    </p>
    <pre class="language-javascript">
function myFunction() {
console.log("Hello, world!");
}

const myArrowFunction = () => {
console.log("Hello, world!");
}

myFunction(); // "Hello, world!"
myArrowFunction(); // "Hello, world!"
    </pre>
    <p class="text-dark-text-secondary mb-4">
      Regular functions are the older way to write functions, While arrow functions were introduced in ES6.
      <br>
      Arrow functions were designed to be more concise and easier to read.
      <br>
      They can also be shortened like this:
      <pre class="language-javascript">
const myArrowFunction = () => console.log("Hello, world!");
myArrowFunction(); // "Hello, world!"

/ And when passing parameters, you can even leave out the parentheses:
const myArrowFunction = name => console.log(`Hello, ${name}!`);
myArrowFunction("John"); // "Hello, John!"
      </pre>

      <section id="callbacks">
        <hr class="my-6 border-t border-dark-border mt-8" />
        <h3 class="text-xl font-semibold text-dark-text mb-4">Callbacks</h3>
        <p class="text-dark-text-secondary mb-4">
          Callbacks are simply functions that are passed as arguments to other functions.
          When passing a function as a parameter, it's important to do so <i>without</i> parentheses:
          <pre class="language-javascript">
function myLogger(text) {
  console.log(text);
}

// for this example, we want to use myLogger as the callback
function myCalculator(num1, num2, callback) {
  let sum = num1 + num2;
  callback(sum);
}

// should be passed without ()
myCalculator(1, 1, myLogger) // 2

// if passed with (), myLogger will just be run immediately.
myCalculator(1, 1, myLogger()) // error
          </pre>
      <p class="text-dark-text-secondary mb-4">
        Callback functions don't seem all that useful in this example,
        but where they do get useful is in asynchronous functions, where functions has to wait
        for another to complete.
      </p>
      

      </section>
      
      
      
    </p>
    
  </section>